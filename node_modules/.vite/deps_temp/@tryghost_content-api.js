import "./chunk-7FP5O474.js";

// node_modules/@tryghost/content-api/es/content-api.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function createCommonjsModule(fn, module2) {
  return module2 = { exports: {} }, fn(module2, module2.exports), module2.exports;
}
var check = function(it) {
  return it && it.Math == Math && it;
};
var global_1 = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || function() {
  return this;
}() || Function("return this")();
var fails = function(exec2) {
  try {
    return !!exec2();
  } catch (error2) {
    return true;
  }
};
var descriptors$1 = !fails(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
});
var functionBindNative = !fails(function() {
  var test2 = function() {
  }.bind();
  return typeof test2 != "function" || test2.hasOwnProperty("prototype");
});
var call$2 = Function.prototype.call;
var functionCall = functionBindNative ? call$2.bind(call$2) : function() {
  return call$2.apply(call$2, arguments);
};
var $propertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$4 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG = getOwnPropertyDescriptor$4 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
var f$6 = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$4(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;
var objectPropertyIsEnumerable = {
  f: f$6
};
var createPropertyDescriptor = function(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value
  };
};
var FunctionPrototype$3 = Function.prototype;
var bind$3 = FunctionPrototype$3.bind;
var call$1 = FunctionPrototype$3.call;
var uncurryThis = functionBindNative && bind$3.bind(call$1, call$1);
var functionUncurryThis = functionBindNative ? function(fn) {
  return fn && uncurryThis(fn);
} : function(fn) {
  return fn && function() {
    return call$1.apply(fn, arguments);
  };
};
var toString$2 = functionUncurryThis({}.toString);
var stringSlice$3 = functionUncurryThis("".slice);
var classofRaw = function(it) {
  return stringSlice$3(toString$2(it), 8, -1);
};
var $Object$3 = Object;
var split = functionUncurryThis("".split);
var indexedObject = fails(function() {
  return !$Object$3("z").propertyIsEnumerable(0);
}) ? function(it) {
  return classofRaw(it) == "String" ? split(it, "") : $Object$3(it);
} : $Object$3;
var $TypeError$e = TypeError;
var requireObjectCoercible = function(it) {
  if (it == void 0)
    throw $TypeError$e("Can't call method on " + it);
  return it;
};
var toIndexedObject = function(it) {
  return indexedObject(requireObjectCoercible(it));
};
var isCallable = function(argument) {
  return typeof argument == "function";
};
var isObject$2 = function(it) {
  return typeof it == "object" ? it !== null : isCallable(it);
};
var aFunction = function(argument) {
  return isCallable(argument) ? argument : void 0;
};
var getBuiltIn = function(namespace, method) {
  return arguments.length < 2 ? aFunction(global_1[namespace]) : global_1[namespace] && global_1[namespace][method];
};
var objectIsPrototypeOf = functionUncurryThis({}.isPrototypeOf);
var engineUserAgent = getBuiltIn("navigator", "userAgent") || "";
var process$4 = global_1.process;
var Deno$1 = global_1.Deno;
var versions = process$4 && process$4.versions || Deno$1 && Deno$1.version;
var v8 = versions && versions.v8;
var match;
var version$1;
if (v8) {
  match = v8.split(".");
  version$1 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}
if (!version$1 && engineUserAgent) {
  match = engineUserAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = engineUserAgent.match(/Chrome\/(\d+)/);
    if (match)
      version$1 = +match[1];
  }
}
var engineV8Version = version$1;
var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function() {
  var symbol = Symbol();
  return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && engineV8Version && engineV8Version < 41;
});
var useSymbolAsUid = nativeSymbol && !Symbol.sham && typeof Symbol.iterator == "symbol";
var $Object$2 = Object;
var isSymbol = useSymbolAsUid ? function(it) {
  return typeof it == "symbol";
} : function(it) {
  var $Symbol = getBuiltIn("Symbol");
  return isCallable($Symbol) && objectIsPrototypeOf($Symbol.prototype, $Object$2(it));
};
var $String$3 = String;
var tryToString = function(argument) {
  try {
    return $String$3(argument);
  } catch (error2) {
    return "Object";
  }
};
var $TypeError$d = TypeError;
var aCallable = function(argument) {
  if (isCallable(argument))
    return argument;
  throw $TypeError$d(tryToString(argument) + " is not a function");
};
var getMethod = function(V, P) {
  var func = V[P];
  return func == null ? void 0 : aCallable(func);
};
var $TypeError$c = TypeError;
var ordinaryToPrimitive = function(input, pref) {
  var fn, val;
  if (pref === "string" && isCallable(fn = input.toString) && !isObject$2(val = functionCall(fn, input)))
    return val;
  if (isCallable(fn = input.valueOf) && !isObject$2(val = functionCall(fn, input)))
    return val;
  if (pref !== "string" && isCallable(fn = input.toString) && !isObject$2(val = functionCall(fn, input)))
    return val;
  throw $TypeError$c("Can't convert object to primitive value");
};
var defineProperty$4 = Object.defineProperty;
var defineGlobalProperty = function(key, value) {
  try {
    defineProperty$4(global_1, key, { value, configurable: true, writable: true });
  } catch (error2) {
    global_1[key] = value;
  }
  return value;
};
var SHARED = "__core-js_shared__";
var store$1 = global_1[SHARED] || defineGlobalProperty(SHARED, {});
var sharedStore = store$1;
var shared = createCommonjsModule(function(module2) {
  (module2.exports = function(key, value) {
    return sharedStore[key] || (sharedStore[key] = value !== void 0 ? value : {});
  })("versions", []).push({
    version: "3.24.1",
    mode: "global",
    copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)",
    license: "https://github.com/zloirock/core-js/blob/v3.24.1/LICENSE",
    source: "https://github.com/zloirock/core-js"
  });
});
var $Object$1 = Object;
var toObject = function(argument) {
  return $Object$1(requireObjectCoercible(argument));
};
var hasOwnProperty$1 = functionUncurryThis({}.hasOwnProperty);
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty$1(toObject(it), key);
};
var id = 0;
var postfix = Math.random();
var toString$1 = functionUncurryThis(1 .toString);
var uid = function(key) {
  return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$1(++id + postfix, 36);
};
var WellKnownSymbolsStore = shared("wks");
var Symbol$1 = global_1.Symbol;
var symbolFor = Symbol$1 && Symbol$1["for"];
var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;
var wellKnownSymbol = function(name2) {
  if (!hasOwnProperty_1(WellKnownSymbolsStore, name2) || !(nativeSymbol || typeof WellKnownSymbolsStore[name2] == "string")) {
    var description = "Symbol." + name2;
    if (nativeSymbol && hasOwnProperty_1(Symbol$1, name2)) {
      WellKnownSymbolsStore[name2] = Symbol$1[name2];
    } else if (useSymbolAsUid && symbolFor) {
      WellKnownSymbolsStore[name2] = symbolFor(description);
    } else {
      WellKnownSymbolsStore[name2] = createWellKnownSymbol(description);
    }
  }
  return WellKnownSymbolsStore[name2];
};
var $TypeError$b = TypeError;
var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
var toPrimitive = function(input, pref) {
  if (!isObject$2(input) || isSymbol(input))
    return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === void 0)
      pref = "default";
    result = functionCall(exoticToPrim, input, pref);
    if (!isObject$2(result) || isSymbol(result))
      return result;
    throw $TypeError$b("Can't convert object to primitive value");
  }
  if (pref === void 0)
    pref = "number";
  return ordinaryToPrimitive(input, pref);
};
var toPropertyKey = function(argument) {
  var key = toPrimitive(argument, "string");
  return isSymbol(key) ? key : key + "";
};
var document$3 = global_1.document;
var EXISTS$1 = isObject$2(document$3) && isObject$2(document$3.createElement);
var documentCreateElement = function(it) {
  return EXISTS$1 ? document$3.createElement(it) : {};
};
var ie8DomDefine = !descriptors$1 && !fails(function() {
  return Object.defineProperty(documentCreateElement("div"), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
});
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var f$5 = descriptors$1 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (ie8DomDefine)
    try {
      return $getOwnPropertyDescriptor$1(O, P);
    } catch (error2) {
    }
  if (hasOwnProperty_1(O, P))
    return createPropertyDescriptor(!functionCall(objectPropertyIsEnumerable.f, O, P), O[P]);
};
var objectGetOwnPropertyDescriptor = {
  f: f$5
};
var v8PrototypeDefineBug = descriptors$1 && fails(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: false
  }).prototype != 42;
});
var $String$2 = String;
var $TypeError$a = TypeError;
var anObject = function(argument) {
  if (isObject$2(argument))
    return argument;
  throw $TypeError$a($String$2(argument) + " is not an object");
};
var $TypeError$9 = TypeError;
var $defineProperty = Object.defineProperty;
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE$1 = "configurable";
var WRITABLE = "writable";
var f$4 = descriptors$1 ? v8PrototypeDefineBug ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }
  return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty2(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (ie8DomDefine)
    try {
      return $defineProperty(O, P, Attributes);
    } catch (error2) {
    }
  if ("get" in Attributes || "set" in Attributes)
    throw $TypeError$9("Accessors not supported");
  if ("value" in Attributes)
    O[P] = Attributes.value;
  return O;
};
var objectDefineProperty = {
  f: f$4
};
var createNonEnumerableProperty = descriptors$1 ? function(object, key, value) {
  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
} : function(object, key, value) {
  object[key] = value;
  return object;
};
var FunctionPrototype$2 = Function.prototype;
var getDescriptor = descriptors$1 && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwnProperty_1(FunctionPrototype$2, "name");
var PROPER = EXISTS && function something() {
}.name === "something";
var CONFIGURABLE = EXISTS && (!descriptors$1 || descriptors$1 && getDescriptor(FunctionPrototype$2, "name").configurable);
var functionName = {
  EXISTS,
  PROPER,
  CONFIGURABLE
};
var functionToString$1 = functionUncurryThis(Function.toString);
if (!isCallable(sharedStore.inspectSource)) {
  sharedStore.inspectSource = function(it) {
    return functionToString$1(it);
  };
}
var inspectSource = sharedStore.inspectSource;
var WeakMap$1 = global_1.WeakMap;
var nativeWeakMap = isCallable(WeakMap$1) && /native code/.test(inspectSource(WeakMap$1));
var keys = shared("keys");
var sharedKey = function(key) {
  return keys[key] || (keys[key] = uid(key));
};
var hiddenKeys$1 = {};
var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
var TypeError$2 = global_1.TypeError;
var WeakMap = global_1.WeakMap;
var set$1;
var get;
var has;
var enforce = function(it) {
  return has(it) ? get(it) : set$1(it, {});
};
var getterFor = function(TYPE) {
  return function(it) {
    var state;
    if (!isObject$2(it) || (state = get(it)).type !== TYPE) {
      throw TypeError$2("Incompatible receiver, " + TYPE + " required");
    }
    return state;
  };
};
if (nativeWeakMap || sharedStore.state) {
  store = sharedStore.state || (sharedStore.state = new WeakMap());
  wmget = functionUncurryThis(store.get);
  wmhas = functionUncurryThis(store.has);
  wmset = functionUncurryThis(store.set);
  set$1 = function(it, metadata) {
    if (wmhas(store, it))
      throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };
  get = function(it) {
    return wmget(store, it) || {};
  };
  has = function(it) {
    return wmhas(store, it);
  };
} else {
  STATE = sharedKey("state");
  hiddenKeys$1[STATE] = true;
  set$1 = function(it, metadata) {
    if (hasOwnProperty_1(it, STATE))
      throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function(it) {
    return hasOwnProperty_1(it, STATE) ? it[STATE] : {};
  };
  has = function(it) {
    return hasOwnProperty_1(it, STATE);
  };
}
var store;
var wmget;
var wmhas;
var wmset;
var STATE;
var internalState = {
  set: set$1,
  get,
  has,
  enforce,
  getterFor
};
var makeBuiltIn_1 = createCommonjsModule(function(module2) {
  var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;
  var enforceInternalState = internalState.enforce;
  var getInternalState2 = internalState.get;
  var defineProperty4 = Object.defineProperty;
  var CONFIGURABLE_LENGTH = descriptors$1 && !fails(function() {
    return defineProperty4(function() {
    }, "length", { value: 8 }).length !== 8;
  });
  var TEMPLATE = String(String).split("String");
  var makeBuiltIn = module2.exports = function(value, name2, options) {
    if (String(name2).slice(0, 7) === "Symbol(") {
      name2 = "[" + String(name2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
    }
    if (options && options.getter)
      name2 = "get " + name2;
    if (options && options.setter)
      name2 = "set " + name2;
    if (!hasOwnProperty_1(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name2) {
      if (descriptors$1)
        defineProperty4(value, "name", { value: name2, configurable: true });
      else
        value.name = name2;
    }
    if (CONFIGURABLE_LENGTH && options && hasOwnProperty_1(options, "arity") && value.length !== options.arity) {
      defineProperty4(value, "length", { value: options.arity });
    }
    try {
      if (options && hasOwnProperty_1(options, "constructor") && options.constructor) {
        if (descriptors$1)
          defineProperty4(value, "prototype", { writable: false });
      } else if (value.prototype)
        value.prototype = void 0;
    } catch (error2) {
    }
    var state = enforceInternalState(value);
    if (!hasOwnProperty_1(state, "source")) {
      state.source = TEMPLATE.join(typeof name2 == "string" ? name2 : "");
    }
    return value;
  };
  Function.prototype.toString = makeBuiltIn(function toString3() {
    return isCallable(this) && getInternalState2(this).source || inspectSource(this);
  }, "toString");
});
var defineBuiltIn = function(O, key, value, options) {
  if (!options)
    options = {};
  var simple = options.enumerable;
  var name2 = options.name !== void 0 ? options.name : key;
  if (isCallable(value))
    makeBuiltIn_1(value, name2, options);
  if (options.global) {
    if (simple)
      O[key] = value;
    else
      defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe)
        delete O[key];
      else if (O[key])
        simple = true;
    } catch (error2) {
    }
    if (simple)
      O[key] = value;
    else
      objectDefineProperty.f(O, key, {
        value,
        enumerable: false,
        configurable: !options.nonConfigurable,
        writable: !options.nonWritable
      });
  }
  return O;
};
var ceil = Math.ceil;
var floor$1 = Math.floor;
var mathTrunc = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor$1 : ceil)(n);
};
var toIntegerOrInfinity = function(argument) {
  var number = +argument;
  return number !== number || number === 0 ? 0 : mathTrunc(number);
};
var max = Math.max;
var min$3 = Math.min;
var toAbsoluteIndex = function(index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min$3(integer, length);
};
var min$2 = Math.min;
var toLength = function(argument) {
  return argument > 0 ? min$2(toIntegerOrInfinity(argument), 9007199254740991) : 0;
};
var lengthOfArrayLike = function(obj) {
  return toLength(obj.length);
};
var createMethod$2 = function(IS_INCLUDES) {
  return function($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    if (IS_INCLUDES && el != el)
      while (length > index) {
        value = O[index++];
        if (value != value)
          return true;
      }
    else
      for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el)
          return IS_INCLUDES || index || 0;
      }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes = {
  includes: createMethod$2(true),
  indexOf: createMethod$2(false)
};
var indexOf$1 = arrayIncludes.indexOf;
var push$1 = functionUncurryThis([].push);
var objectKeysInternal = function(object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O)
    !hasOwnProperty_1(hiddenKeys$1, key) && hasOwnProperty_1(O, key) && push$1(result, key);
  while (names.length > i)
    if (hasOwnProperty_1(O, key = names[i++])) {
      ~indexOf$1(result, key) || push$1(result, key);
    }
  return result;
};
var enumBugKeys = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
];
var hiddenKeys = enumBugKeys.concat("length", "prototype");
var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return objectKeysInternal(O, hiddenKeys);
};
var objectGetOwnPropertyNames = {
  f: f$3
};
var f$2 = Object.getOwnPropertySymbols;
var objectGetOwnPropertySymbols = {
  f: f$2
};
var concat$1 = functionUncurryThis([].concat);
var ownKeys = getBuiltIn("Reflect", "ownKeys") || function ownKeys2(it) {
  var keys4 = objectGetOwnPropertyNames.f(anObject(it));
  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
  return getOwnPropertySymbols ? concat$1(keys4, getOwnPropertySymbols(it)) : keys4;
};
var copyConstructorProperties = function(target, source3, exceptions) {
  var keys4 = ownKeys(source3);
  var defineProperty4 = objectDefineProperty.f;
  var getOwnPropertyDescriptor3 = objectGetOwnPropertyDescriptor.f;
  for (var i = 0; i < keys4.length; i++) {
    var key = keys4[i];
    if (!hasOwnProperty_1(target, key) && !(exceptions && hasOwnProperty_1(exceptions, key))) {
      defineProperty4(target, key, getOwnPropertyDescriptor3(source3, key));
    }
  }
};
var replacement = /#|\.prototype\./;
var isForced = function(feature, detection) {
  var value = data$1[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
};
var normalize = isForced.normalize = function(string) {
  return String(string).replace(replacement, ".").toLowerCase();
};
var data$1 = isForced.data = {};
var NATIVE = isForced.NATIVE = "N";
var POLYFILL = isForced.POLYFILL = "P";
var isForced_1 = isForced;
var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;
var _export = function(options, source3) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED2, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global_1;
  } else if (STATIC) {
    target = global_1[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global_1[TARGET] || {}).prototype;
  }
  if (target)
    for (key in source3) {
      sourceProperty = source3[key];
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor$3(target, key);
        targetProperty = descriptor && descriptor.value;
      } else
        targetProperty = target[key];
      FORCED2 = isForced_1(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED2 && targetProperty !== void 0) {
        if (typeof sourceProperty == typeof targetProperty)
          continue;
        copyConstructorProperties(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty(sourceProperty, "sham", true);
      }
      defineBuiltIn(target, key, sourceProperty, options);
    }
};
var TO_STRING_TAG$2 = wellKnownSymbol("toStringTag");
var test = {};
test[TO_STRING_TAG$2] = "z";
var toStringTagSupport = String(test) === "[object z]";
var TO_STRING_TAG$1 = wellKnownSymbol("toStringTag");
var $Object = Object;
var CORRECT_ARGUMENTS = classofRaw(function() {
  return arguments;
}()) == "Arguments";
var tryGet = function(it, key) {
  try {
    return it[key];
  } catch (error2) {
  }
};
var classof = toStringTagSupport ? classofRaw : function(it) {
  var O, tag, result;
  return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG$1)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable(O.callee) ? "Arguments" : result;
};
var $String$1 = String;
var toString_1 = function(argument) {
  if (classof(argument) === "Symbol")
    throw TypeError("Cannot convert a Symbol value to a string");
  return $String$1(argument);
};
var regexpFlags = function() {
  var that = anObject(this);
  var result = "";
  if (that.hasIndices)
    result += "d";
  if (that.global)
    result += "g";
  if (that.ignoreCase)
    result += "i";
  if (that.multiline)
    result += "m";
  if (that.dotAll)
    result += "s";
  if (that.unicode)
    result += "u";
  if (that.unicodeSets)
    result += "v";
  if (that.sticky)
    result += "y";
  return result;
};
var $RegExp$2 = global_1.RegExp;
var UNSUPPORTED_Y$1 = fails(function() {
  var re = $RegExp$2("a", "y");
  re.lastIndex = 2;
  return re.exec("abcd") != null;
});
var MISSED_STICKY = UNSUPPORTED_Y$1 || fails(function() {
  return !$RegExp$2("a", "y").sticky;
});
var BROKEN_CARET = UNSUPPORTED_Y$1 || fails(function() {
  var re = $RegExp$2("^r", "gy");
  re.lastIndex = 2;
  return re.exec("str") != null;
});
var regexpStickyHelpers = {
  BROKEN_CARET,
  MISSED_STICKY,
  UNSUPPORTED_Y: UNSUPPORTED_Y$1
};
var objectKeys$1 = Object.keys || function keys2(O) {
  return objectKeysInternal(O, enumBugKeys);
};
var f$1 = descriptors$1 && !v8PrototypeDefineBug ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys4 = objectKeys$1(Properties);
  var length = keys4.length;
  var index = 0;
  var key;
  while (length > index)
    objectDefineProperty.f(O, key = keys4[index++], props[key]);
  return O;
};
var objectDefineProperties = {
  f: f$1
};
var html = getBuiltIn("document", "documentElement");
var GT = ">";
var LT = "<";
var PROTOTYPE = "prototype";
var SCRIPT = "script";
var IE_PROTO = sharedKey("IE_PROTO");
var EmptyConstructor = function() {
};
var scriptTag = function(content) {
  return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
};
var NullProtoObjectViaActiveX = function(activeXDocument2) {
  activeXDocument2.write(scriptTag(""));
  activeXDocument2.close();
  var temp = activeXDocument2.parentWindow.Object;
  activeXDocument2 = null;
  return temp;
};
var NullProtoObjectViaIFrame = function() {
  var iframe = documentCreateElement("iframe");
  var JS = "java" + SCRIPT + ":";
  var iframeDocument;
  iframe.style.display = "none";
  html.appendChild(iframe);
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag("document.F=Object"));
  iframeDocument.close();
  return iframeDocument.F;
};
var activeXDocument;
var NullProtoObject = function() {
  try {
    activeXDocument = new ActiveXObject("htmlfile");
  } catch (error2) {
  }
  NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
  var length = enumBugKeys.length;
  while (length--)
    delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};
hiddenKeys$1[IE_PROTO] = true;
var objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    result[IE_PROTO] = O;
  } else
    result = NullProtoObject();
  return Properties === void 0 ? result : objectDefineProperties.f(result, Properties);
};
var $RegExp$1 = global_1.RegExp;
var regexpUnsupportedDotAll = fails(function() {
  var re = $RegExp$1(".", "s");
  return !(re.dotAll && re.exec("\n") && re.flags === "s");
});
var $RegExp = global_1.RegExp;
var regexpUnsupportedNcg = fails(function() {
  var re = $RegExp("(?<a>b)", "g");
  return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
});
var getInternalState = internalState.get;
var nativeReplace = shared("native-string-replace", String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt$2 = functionUncurryThis("".charAt);
var indexOf = functionUncurryThis("".indexOf);
var replace = functionUncurryThis("".replace);
var stringSlice$2 = functionUncurryThis("".slice);
var UPDATES_LAST_INDEX_WRONG = function() {
  var re1 = /a/;
  var re2 = /b*/g;
  functionCall(nativeExec, re1, "a");
  functionCall(nativeExec, re2, "a");
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
}();
var UNSUPPORTED_Y = regexpStickyHelpers.BROKEN_CARET;
var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || regexpUnsupportedDotAll || regexpUnsupportedNcg;
if (PATCH) {
  patchedExec = function exec2(string) {
    var re = this;
    var state = getInternalState(re);
    var str = toString_1(string);
    var raw = state.raw;
    var result, reCopy, lastIndex, match2, i, object, group;
    if (raw) {
      raw.lastIndex = re.lastIndex;
      result = functionCall(patchedExec, raw, str);
      re.lastIndex = raw.lastIndex;
      return result;
    }
    var groups = state.groups;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = functionCall(regexpFlags, re);
    var source3 = re.source;
    var charsAdded = 0;
    var strCopy = str;
    if (sticky) {
      flags = replace(flags, "y", "");
      if (indexOf(flags, "g") === -1) {
        flags += "g";
      }
      strCopy = stringSlice$2(str, re.lastIndex);
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$2(str, re.lastIndex - 1) !== "\n")) {
        source3 = "(?: " + source3 + ")";
        strCopy = " " + strCopy;
        charsAdded++;
      }
      reCopy = new RegExp("^(?:" + source3 + ")", flags);
    }
    if (NPCG_INCLUDED) {
      reCopy = new RegExp("^" + source3 + "$(?!\\s)", flags);
    }
    if (UPDATES_LAST_INDEX_WRONG)
      lastIndex = re.lastIndex;
    match2 = functionCall(nativeExec, sticky ? reCopy : re, strCopy);
    if (sticky) {
      if (match2) {
        match2.input = stringSlice$2(match2.input, charsAdded);
        match2[0] = stringSlice$2(match2[0], charsAdded);
        match2.index = re.lastIndex;
        re.lastIndex += match2[0].length;
      } else
        re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match2) {
      re.lastIndex = re.global ? match2.index + match2[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match2 && match2.length > 1) {
      functionCall(nativeReplace, match2[0], reCopy, function() {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === void 0)
            match2[i] = void 0;
        }
      });
    }
    if (match2 && groups) {
      match2.groups = object = objectCreate(null);
      for (i = 0; i < groups.length; i++) {
        group = groups[i];
        object[group[0]] = match2[group[1]];
      }
    }
    return match2;
  };
}
var regexpExec = patchedExec;
_export({ target: "RegExp", proto: true, forced: /./.exec !== regexpExec }, {
  exec: regexpExec
});
var SPECIES$5 = wellKnownSymbol("species");
var RegExpPrototype = RegExp.prototype;
var fixRegexpWellKnownSymbolLogic = function(KEY, exec2, FORCED2, SHAM) {
  var SYMBOL = wellKnownSymbol(KEY);
  var DELEGATES_TO_SYMBOL = !fails(function() {
    var O = {};
    O[SYMBOL] = function() {
      return 7;
    };
    return ""[KEY](O) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
    var execCalled = false;
    var re = /a/;
    if (KEY === "split") {
      re = {};
      re.constructor = {};
      re.constructor[SPECIES$5] = function() {
        return re;
      };
      re.flags = "";
      re[SYMBOL] = /./[SYMBOL];
    }
    re.exec = function() {
      execCalled = true;
      return null;
    };
    re[SYMBOL]("");
    return !execCalled;
  });
  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED2) {
    var uncurriedNativeRegExpMethod = functionUncurryThis(/./[SYMBOL]);
    var methods = exec2(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
      var uncurriedNativeMethod = functionUncurryThis(nativeMethod);
      var $exec = regexp.exec;
      if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
        }
        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
      }
      return { done: false };
    });
    defineBuiltIn(String.prototype, KEY, methods[0]);
    defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
  }
  if (SHAM)
    createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
};
var charAt$1 = functionUncurryThis("".charAt);
var charCodeAt = functionUncurryThis("".charCodeAt);
var stringSlice$1 = functionUncurryThis("".slice);
var createMethod$1 = function(CONVERT_TO_STRING) {
  return function($this, pos) {
    var S = toString_1(requireObjectCoercible($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size)
      return CONVERT_TO_STRING ? "" : void 0;
    first = charCodeAt(S, position);
    return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt$1(S, position) : first : CONVERT_TO_STRING ? stringSlice$1(S, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
  };
};
var stringMultibyte = {
  codeAt: createMethod$1(false),
  charAt: createMethod$1(true)
};
var charAt = stringMultibyte.charAt;
var advanceStringIndex = function(S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};
var $TypeError$8 = TypeError;
var regexpExecAbstract = function(R, S) {
  var exec2 = R.exec;
  if (isCallable(exec2)) {
    var result = functionCall(exec2, R, S);
    if (result !== null)
      anObject(result);
    return result;
  }
  if (classofRaw(R) === "RegExp")
    return functionCall(regexpExec, R, S);
  throw $TypeError$8("RegExp#exec called on incompatible receiver");
};
fixRegexpWellKnownSymbolLogic("match", function(MATCH2, nativeMatch, maybeCallNative) {
  return [
    function match2(regexp) {
      var O = requireObjectCoercible(this);
      var matcher = regexp == void 0 ? void 0 : getMethod(regexp, MATCH2);
      return matcher ? functionCall(matcher, regexp, O) : new RegExp(regexp)[MATCH2](toString_1(O));
    },
    function(string) {
      var rx = anObject(this);
      var S = toString_1(string);
      var res = maybeCallNative(nativeMatch, rx, S);
      if (res.done)
        return res.value;
      if (!rx.global)
        return regexpExecAbstract(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regexpExecAbstract(rx, S)) !== null) {
        var matchStr = toString_1(result[0]);
        A[n] = matchStr;
        if (matchStr === "")
          rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});
var arrayMethodIsStrict = function(METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function() {
    method.call(null, argument || function() {
      return 1;
    }, 1);
  });
};
var un$Join = functionUncurryThis([].join);
var ES3_STRINGS = indexedObject != Object;
var STRICT_METHOD$1 = arrayMethodIsStrict("join", ",");
_export({ target: "Array", proto: true, forced: ES3_STRINGS || !STRICT_METHOD$1 }, {
  join: function join(separator) {
    return un$Join(toIndexedObject(this), separator === void 0 ? "," : separator);
  }
});
var objectToString = toStringTagSupport ? {}.toString : function toString() {
  return "[object " + classof(this) + "]";
};
if (!toStringTagSupport) {
  defineBuiltIn(Object.prototype, "toString", objectToString, { unsafe: true });
}
var FAILS_ON_PRIMITIVES = fails(function() {
  objectKeys$1(1);
});
_export({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys3(it) {
    return objectKeys$1(toObject(it));
  }
});
var isArray$2 = Array.isArray || function isArray(argument) {
  return classofRaw(argument) == "Array";
};
var $TypeError$7 = TypeError;
var MAX_SAFE_INTEGER = 9007199254740991;
var doesNotExceedSafeInteger = function(it) {
  if (it > MAX_SAFE_INTEGER)
    throw $TypeError$7("Maximum allowed index exceeded");
  return it;
};
var createProperty = function(object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object)
    objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
  else
    object[propertyKey] = value;
};
var noop = function() {
};
var empty = [];
var construct = getBuiltIn("Reflect", "construct");
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = functionUncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument))
    return false;
  try {
    construct(noop, empty, argument);
    return true;
  } catch (error2) {
    return false;
  }
};
var isConstructorLegacy = function isConstructor2(argument) {
  if (!isCallable(argument))
    return false;
  switch (classof(argument)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error2) {
    return true;
  }
};
isConstructorLegacy.sham = true;
var isConstructor3 = !construct || fails(function() {
  var called;
  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
    called = true;
  }) || called;
}) ? isConstructorLegacy : isConstructorModern;
var SPECIES$4 = wellKnownSymbol("species");
var $Array = Array;
var arraySpeciesConstructor = function(originalArray) {
  var C;
  if (isArray$2(originalArray)) {
    C = originalArray.constructor;
    if (isConstructor3(C) && (C === $Array || isArray$2(C.prototype)))
      C = void 0;
    else if (isObject$2(C)) {
      C = C[SPECIES$4];
      if (C === null)
        C = void 0;
    }
  }
  return C === void 0 ? $Array : C;
};
var arraySpeciesCreate = function(originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};
var SPECIES$3 = wellKnownSymbol("species");
var arrayMethodHasSpeciesSupport = function(METHOD_NAME) {
  return engineV8Version >= 51 || !fails(function() {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES$3] = function() {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};
var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function() {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});
var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
var isConcatSpreadable = function(O) {
  if (!isObject$2(O))
    return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== void 0 ? !!spreadable : isArray$2(O);
};
var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
_export({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike(E);
        doesNotExceedSafeInteger(n + len);
        for (k = 0; k < len; k++, n++)
          if (k in E)
            createProperty(A, n, E[k]);
      } else {
        doesNotExceedSafeInteger(n + 1);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});
var defineProperty$3 = objectDefineProperty.f;
var UNSCOPABLES = wellKnownSymbol("unscopables");
var ArrayPrototype$1 = Array.prototype;
if (ArrayPrototype$1[UNSCOPABLES] == void 0) {
  defineProperty$3(ArrayPrototype$1, UNSCOPABLES, {
    configurable: true,
    value: objectCreate(null)
  });
}
var addToUnscopables = function(key) {
  ArrayPrototype$1[UNSCOPABLES][key] = true;
};
var $includes = arrayIncludes.includes;
var BROKEN_ON_SPARSE = fails(function() {
  return !Array(1).includes();
});
_export({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, {
  includes: function includes(el) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables("includes");
var MATCH$1 = wellKnownSymbol("match");
var isRegexp = function(it) {
  var isRegExp;
  return isObject$2(it) && ((isRegExp = it[MATCH$1]) !== void 0 ? !!isRegExp : classofRaw(it) == "RegExp");
};
var $TypeError$6 = TypeError;
var notARegexp = function(it) {
  if (isRegexp(it)) {
    throw $TypeError$6("The method doesn't accept regular expressions");
  }
  return it;
};
var MATCH = wellKnownSymbol("match");
var correctIsRegexpLogic = function(METHOD_NAME) {
  var regexp = /./;
  try {
    "/./"[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return "/./"[METHOD_NAME](regexp);
    } catch (error2) {
    }
  }
  return false;
};
var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
var un$EndsWith = functionUncurryThis("".endsWith);
var slice = functionUncurryThis("".slice);
var min$1 = Math.min;
var CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegexpLogic("endsWith");
var MDN_POLYFILL_BUG$1 = !CORRECT_IS_REGEXP_LOGIC$1 && !!function() {
  var descriptor = getOwnPropertyDescriptor$2(String.prototype, "endsWith");
  return descriptor && !descriptor.writable;
}();
_export({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG$1 && !CORRECT_IS_REGEXP_LOGIC$1 }, {
  endsWith: function endsWith(searchString) {
    var that = toString_1(requireObjectCoercible(this));
    notARegexp(searchString);
    var endPosition = arguments.length > 1 ? arguments[1] : void 0;
    var len = that.length;
    var end = endPosition === void 0 ? len : min$1(toLength(endPosition), len);
    var search = toString_1(searchString);
    return un$EndsWith ? un$EndsWith(that, search, end) : slice(that, end - search.length, end) === search;
  }
});
var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var un$StartsWith = functionUncurryThis("".startsWith);
var stringSlice = functionUncurryThis("".slice);
var min = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic("startsWith");
var MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function() {
  var descriptor = getOwnPropertyDescriptor$1(String.prototype, "startsWith");
  return descriptor && !descriptor.writable;
}();
_export({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
  startsWith: function startsWith(searchString) {
    var that = toString_1(requireObjectCoercible(this));
    notARegexp(searchString);
    var index = toLength(min(arguments.length > 1 ? arguments[1] : void 0, that.length));
    var search = toString_1(searchString);
    return un$StartsWith ? un$StartsWith(that, search, index) : stringSlice(that, index, index + search.length) === search;
  }
});
var engineIsNode = classofRaw(global_1.process) == "process";
var $String = String;
var $TypeError$5 = TypeError;
var aPossiblePrototype = function(argument) {
  if (typeof argument == "object" || isCallable(argument))
    return argument;
  throw $TypeError$5("Can't set " + $String(argument) + " as a prototype");
};
var objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var CORRECT_SETTER = false;
  var test2 = {};
  var setter;
  try {
    setter = functionUncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set);
    setter(test2, []);
    CORRECT_SETTER = test2 instanceof Array;
  } catch (error2) {
  }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER)
      setter(O, proto);
    else
      O.__proto__ = proto;
    return O;
  };
}() : void 0);
var defineProperty$2 = objectDefineProperty.f;
var TO_STRING_TAG = wellKnownSymbol("toStringTag");
var setToStringTag = function(target, TAG, STATIC) {
  if (target && !STATIC)
    target = target.prototype;
  if (target && !hasOwnProperty_1(target, TO_STRING_TAG)) {
    defineProperty$2(target, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};
var SPECIES$2 = wellKnownSymbol("species");
var setSpecies = function(CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty4 = objectDefineProperty.f;
  if (descriptors$1 && Constructor && !Constructor[SPECIES$2]) {
    defineProperty4(Constructor, SPECIES$2, {
      configurable: true,
      get: function() {
        return this;
      }
    });
  }
};
var $TypeError$4 = TypeError;
var anInstance = function(it, Prototype) {
  if (objectIsPrototypeOf(Prototype, it))
    return it;
  throw $TypeError$4("Incorrect invocation");
};
var $TypeError$3 = TypeError;
var aConstructor = function(argument) {
  if (isConstructor3(argument))
    return argument;
  throw $TypeError$3(tryToString(argument) + " is not a constructor");
};
var SPECIES$1 = wellKnownSymbol("species");
var speciesConstructor = function(O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === void 0 || (S = anObject(C)[SPECIES$1]) == void 0 ? defaultConstructor : aConstructor(S);
};
var FunctionPrototype$1 = Function.prototype;
var apply = FunctionPrototype$1.apply;
var call = FunctionPrototype$1.call;
var functionApply = typeof Reflect == "object" && Reflect.apply || (functionBindNative ? call.bind(apply) : function() {
  return call.apply(apply, arguments);
});
var bind$2 = functionUncurryThis(functionUncurryThis.bind);
var functionBindContext = function(fn, that) {
  aCallable(fn);
  return that === void 0 ? fn : functionBindNative ? bind$2(fn, that) : function() {
    return fn.apply(that, arguments);
  };
};
var arraySlice = functionUncurryThis([].slice);
var $TypeError$2 = TypeError;
var validateArgumentsLength = function(passed, required) {
  if (passed < required)
    throw $TypeError$2("Not enough arguments");
  return passed;
};
var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(engineUserAgent);
var set = global_1.setImmediate;
var clear = global_1.clearImmediate;
var process$3 = global_1.process;
var Dispatch = global_1.Dispatch;
var Function$1 = global_1.Function;
var MessageChannel = global_1.MessageChannel;
var String$1 = global_1.String;
var counter = 0;
var queue$1 = {};
var ONREADYSTATECHANGE = "onreadystatechange";
var location;
var defer;
var channel;
var port;
try {
  location = global_1.location;
} catch (error2) {
}
var run = function(id2) {
  if (hasOwnProperty_1(queue$1, id2)) {
    var fn = queue$1[id2];
    delete queue$1[id2];
    fn();
  }
};
var runner = function(id2) {
  return function() {
    run(id2);
  };
};
var listener = function(event) {
  run(event.data);
};
var post = function(id2) {
  global_1.postMessage(String$1(id2), location.protocol + "//" + location.host);
};
if (!set || !clear) {
  set = function setImmediate(handler) {
    validateArgumentsLength(arguments.length, 1);
    var fn = isCallable(handler) ? handler : Function$1(handler);
    var args = arraySlice(arguments, 1);
    queue$1[++counter] = function() {
      functionApply(fn, void 0, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id2) {
    delete queue$1[id2];
  };
  if (engineIsNode) {
    defer = function(id2) {
      process$3.nextTick(runner(id2));
    };
  } else if (Dispatch && Dispatch.now) {
    defer = function(id2) {
      Dispatch.now(runner(id2));
    };
  } else if (MessageChannel && !engineIsIos) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = functionBindContext(port.postMessage, port);
  } else if (global_1.addEventListener && isCallable(global_1.postMessage) && !global_1.importScripts && location && location.protocol !== "file:" && !fails(post)) {
    defer = post;
    global_1.addEventListener("message", listener, false);
  } else if (ONREADYSTATECHANGE in documentCreateElement("script")) {
    defer = function(id2) {
      html.appendChild(documentCreateElement("script"))[ONREADYSTATECHANGE] = function() {
        html.removeChild(this);
        run(id2);
      };
    };
  } else {
    defer = function(id2) {
      setTimeout(runner(id2), 0);
    };
  }
}
var task$1 = {
  set,
  clear
};
var engineIsIosPebble = /ipad|iphone|ipod/i.test(engineUserAgent) && global_1.Pebble !== void 0;
var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(engineUserAgent);
var getOwnPropertyDescriptor2 = objectGetOwnPropertyDescriptor.f;
var macrotask = task$1.set;
var MutationObserver = global_1.MutationObserver || global_1.WebKitMutationObserver;
var document$2 = global_1.document;
var process$2 = global_1.process;
var Promise$1 = global_1.Promise;
var queueMicrotaskDescriptor = getOwnPropertyDescriptor2(global_1, "queueMicrotask");
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var flush;
var head;
var last;
var notify$1;
var toggle;
var node;
var promise;
var then;
if (!queueMicrotask) {
  flush = function() {
    var parent, fn;
    if (engineIsNode && (parent = process$2.domain))
      parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error2) {
        if (head)
          notify$1();
        else
          last = void 0;
        throw error2;
      }
    }
    last = void 0;
    if (parent)
      parent.enter();
  };
  if (!engineIsIos && !engineIsNode && !engineIsWebosWebkit && MutationObserver && document$2) {
    toggle = true;
    node = document$2.createTextNode("");
    new MutationObserver(flush).observe(node, { characterData: true });
    notify$1 = function() {
      node.data = toggle = !toggle;
    };
  } else if (!engineIsIosPebble && Promise$1 && Promise$1.resolve) {
    promise = Promise$1.resolve(void 0);
    promise.constructor = Promise$1;
    then = functionBindContext(promise.then, promise);
    notify$1 = function() {
      then(flush);
    };
  } else if (engineIsNode) {
    notify$1 = function() {
      process$2.nextTick(flush);
    };
  } else {
    macrotask = functionBindContext(macrotask, global_1);
    notify$1 = function() {
      macrotask(flush);
    };
  }
}
var microtask = queueMicrotask || function(fn) {
  var task2 = { fn, next: void 0 };
  if (last)
    last.next = task2;
  if (!head) {
    head = task2;
    notify$1();
  }
  last = task2;
};
var hostReportErrors = function(a, b) {
  var console2 = global_1.console;
  if (console2 && console2.error) {
    arguments.length == 1 ? console2.error(a) : console2.error(a, b);
  }
};
var perform = function(exec2) {
  try {
    return { error: false, value: exec2() };
  } catch (error2) {
    return { error: true, value: error2 };
  }
};
var Queue = function() {
  this.head = null;
  this.tail = null;
};
Queue.prototype = {
  add: function(item) {
    var entry = { item, next: null };
    if (this.head)
      this.tail.next = entry;
    else
      this.head = entry;
    this.tail = entry;
  },
  get: function() {
    var entry = this.head;
    if (entry) {
      this.head = entry.next;
      if (this.tail === entry)
        this.tail = null;
      return entry.item;
    }
  }
};
var queue = Queue;
var promiseNativeConstructor = global_1.Promise;
var engineIsDeno = typeof Deno == "object" && Deno && typeof Deno.version == "object";
var engineIsBrowser = !engineIsDeno && !engineIsNode && typeof window == "object" && typeof document == "object";
promiseNativeConstructor && promiseNativeConstructor.prototype;
var SPECIES = wellKnownSymbol("species");
var SUBCLASSING = false;
var NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable(global_1.PromiseRejectionEvent);
var FORCED_PROMISE_CONSTRUCTOR$5 = isForced_1("Promise", function() {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(promiseNativeConstructor);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(promiseNativeConstructor);
  if (!GLOBAL_CORE_JS_PROMISE && engineV8Version === 66)
    return true;
  if (!engineV8Version || engineV8Version < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
    var promise2 = new promiseNativeConstructor(function(resolve2) {
      resolve2(1);
    });
    var FakePromise = function(exec2) {
      exec2(function() {
      }, function() {
      });
    };
    var constructor = promise2.constructor = {};
    constructor[SPECIES] = FakePromise;
    SUBCLASSING = promise2.then(function() {
    }) instanceof FakePromise;
    if (!SUBCLASSING)
      return true;
  }
  return !GLOBAL_CORE_JS_PROMISE && (engineIsBrowser || engineIsDeno) && !NATIVE_PROMISE_REJECTION_EVENT$1;
});
var promiseConstructorDetection = {
  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,
  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,
  SUBCLASSING
};
var PromiseCapability = function(C) {
  var resolve2, reject2;
  this.promise = new C(function($$resolve, $$reject) {
    if (resolve2 !== void 0 || reject2 !== void 0)
      throw TypeError("Bad Promise constructor");
    resolve2 = $$resolve;
    reject2 = $$reject;
  });
  this.resolve = aCallable(resolve2);
  this.reject = aCallable(reject2);
};
var f = function(C) {
  return new PromiseCapability(C);
};
var newPromiseCapability$1 = {
  f
};
var task = task$1.set;
var PROMISE = "Promise";
var FORCED_PROMISE_CONSTRUCTOR$4 = promiseConstructorDetection.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT = promiseConstructorDetection.REJECTION_EVENT;
var NATIVE_PROMISE_SUBCLASSING = promiseConstructorDetection.SUBCLASSING;
var getInternalPromiseState = internalState.getterFor(PROMISE);
var setInternalState = internalState.set;
var NativePromisePrototype$1 = promiseNativeConstructor && promiseNativeConstructor.prototype;
var PromiseConstructor = promiseNativeConstructor;
var PromisePrototype = NativePromisePrototype$1;
var TypeError$1 = global_1.TypeError;
var document$1 = global_1.document;
var process$1 = global_1.process;
var newPromiseCapability = newPromiseCapability$1.f;
var newGenericPromiseCapability = newPromiseCapability;
var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global_1.dispatchEvent);
var UNHANDLED_REJECTION = "unhandledrejection";
var REJECTION_HANDLED = "rejectionhandled";
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal;
var OwnPromiseCapability;
var PromiseWrapper;
var nativeThen;
var isThenable = function(it) {
  var then2;
  return isObject$2(it) && isCallable(then2 = it.then) ? then2 : false;
};
var callReaction = function(reaction, state) {
  var value = state.value;
  var ok = state.state == FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve2 = reaction.resolve;
  var reject2 = reaction.reject;
  var domain = reaction.domain;
  var result, then2, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED)
          onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true)
        result = value;
      else {
        if (domain)
          domain.enter();
        result = handler(value);
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject2(TypeError$1("Promise-chain cycle"));
      } else if (then2 = isThenable(result)) {
        functionCall(then2, result, resolve2, reject2);
      } else
        resolve2(result);
    } else
      reject2(value);
  } catch (error2) {
    if (domain && !exited)
      domain.exit();
    reject2(error2);
  }
};
var notify = function(state, isReject) {
  if (state.notified)
    return;
  state.notified = true;
  microtask(function() {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection)
      onUnhandled(state);
  });
};
var dispatchEvent = function(name2, promise2, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document$1.createEvent("Event");
    event.promise = promise2;
    event.reason = reason;
    event.initEvent(name2, false, true);
    global_1.dispatchEvent(event);
  } else
    event = { promise: promise2, reason };
  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global_1["on" + name2]))
    handler(event);
  else if (name2 === UNHANDLED_REJECTION)
    hostReportErrors("Unhandled promise rejection", reason);
};
var onUnhandled = function(state) {
  functionCall(task, global_1, function() {
    var promise2 = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function() {
        if (engineIsNode) {
          process$1.emit("unhandledRejection", value, promise2);
        } else
          dispatchEvent(UNHANDLED_REJECTION, promise2, value);
      });
      state.rejection = engineIsNode || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error)
        throw result.value;
    }
  });
};
var isUnhandled = function(state) {
  return state.rejection !== HANDLED && !state.parent;
};
var onHandleUnhandled = function(state) {
  functionCall(task, global_1, function() {
    var promise2 = state.facade;
    if (engineIsNode) {
      process$1.emit("rejectionHandled", promise2);
    } else
      dispatchEvent(REJECTION_HANDLED, promise2, state.value);
  });
};
var bind$1 = function(fn, state, unwrap) {
  return function(value) {
    fn(state, value, unwrap);
  };
};
var internalReject = function(state, value, unwrap) {
  if (state.done)
    return;
  state.done = true;
  if (unwrap)
    state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};
var internalResolve = function(state, value, unwrap) {
  if (state.done)
    return;
  state.done = true;
  if (unwrap)
    state = unwrap;
  try {
    if (state.facade === value)
      throw TypeError$1("Promise can't be resolved itself");
    var then2 = isThenable(value);
    if (then2) {
      microtask(function() {
        var wrapper = { done: false };
        try {
          functionCall(
            then2,
            value,
            bind$1(internalResolve, wrapper, state),
            bind$1(internalReject, wrapper, state)
          );
        } catch (error2) {
          internalReject(wrapper, error2, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error2) {
    internalReject({ done: false }, error2, state);
  }
};
if (FORCED_PROMISE_CONSTRUCTOR$4) {
  PromiseConstructor = function Promise2(executor) {
    anInstance(this, PromisePrototype);
    aCallable(executor);
    functionCall(Internal, this);
    var state = getInternalPromiseState(this);
    try {
      executor(bind$1(internalResolve, state), bind$1(internalReject, state));
    } catch (error2) {
      internalReject(state, error2);
    }
  };
  PromisePrototype = PromiseConstructor.prototype;
  Internal = function Promise2(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new queue(),
      rejection: false,
      state: PENDING,
      value: void 0
    });
  };
  Internal.prototype = defineBuiltIn(PromisePrototype, "then", function then2(onFulfilled, onRejected) {
    var state = getInternalPromiseState(this);
    var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
    state.parent = true;
    reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
    reaction.fail = isCallable(onRejected) && onRejected;
    reaction.domain = engineIsNode ? process$1.domain : void 0;
    if (state.state == PENDING)
      state.reactions.add(reaction);
    else
      microtask(function() {
        callReaction(reaction, state);
      });
    return reaction.promise;
  });
  OwnPromiseCapability = function() {
    var promise2 = new Internal();
    var state = getInternalPromiseState(promise2);
    this.promise = promise2;
    this.resolve = bind$1(internalResolve, state);
    this.reject = bind$1(internalReject, state);
  };
  newPromiseCapability$1.f = newPromiseCapability = function(C) {
    return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
  if (isCallable(promiseNativeConstructor) && NativePromisePrototype$1 !== Object.prototype) {
    nativeThen = NativePromisePrototype$1.then;
    if (!NATIVE_PROMISE_SUBCLASSING) {
      defineBuiltIn(NativePromisePrototype$1, "then", function then2(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function(resolve2, reject2) {
          functionCall(nativeThen, that, resolve2, reject2);
        }).then(onFulfilled, onRejected);
      }, { unsafe: true });
    }
    try {
      delete NativePromisePrototype$1.constructor;
    } catch (error2) {
    }
    if (objectSetPrototypeOf) {
      objectSetPrototypeOf(NativePromisePrototype$1, PromisePrototype);
    }
  }
}
_export({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {
  Promise: PromiseConstructor
});
setToStringTag(PromiseConstructor, PROMISE, false);
setSpecies(PROMISE);
var iterators = {};
var ITERATOR$2 = wellKnownSymbol("iterator");
var ArrayPrototype = Array.prototype;
var isArrayIteratorMethod = function(it) {
  return it !== void 0 && (iterators.Array === it || ArrayPrototype[ITERATOR$2] === it);
};
var ITERATOR$1 = wellKnownSymbol("iterator");
var getIteratorMethod = function(it) {
  if (it != void 0)
    return getMethod(it, ITERATOR$1) || getMethod(it, "@@iterator") || iterators[classof(it)];
};
var $TypeError$1 = TypeError;
var getIterator = function(argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
  if (aCallable(iteratorMethod))
    return anObject(functionCall(iteratorMethod, argument));
  throw $TypeError$1(tryToString(argument) + " is not iterable");
};
var iteratorClose = function(iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, "return");
    if (!innerResult) {
      if (kind === "throw")
        throw value;
      return value;
    }
    innerResult = functionCall(innerResult, iterator);
  } catch (error2) {
    innerError = true;
    innerResult = error2;
  }
  if (kind === "throw")
    throw value;
  if (innerError)
    throw innerResult;
  anObject(innerResult);
  return value;
};
var $TypeError = TypeError;
var Result = function(stopped, result) {
  this.stopped = stopped;
  this.result = result;
};
var ResultPrototype = Result.prototype;
var iterate = function(iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = functionBindContext(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;
  var stop = function(condition) {
    if (iterator)
      iteratorClose(iterator, "normal", condition);
    return new Result(true, condition);
  };
  var callFn = function(value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    }
    return INTERRUPTED ? fn(value, stop) : fn(value);
  };
  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn)
      throw $TypeError(tryToString(iterable) + " is not iterable");
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && objectIsPrototypeOf(ResultPrototype, result))
          return result;
      }
      return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }
  next = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = functionCall(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error2) {
      iteratorClose(iterator, "throw", error2);
    }
    if (typeof result == "object" && result && objectIsPrototypeOf(ResultPrototype, result))
      return result;
  }
  return new Result(false);
};
var ITERATOR = wellKnownSymbol("iterator");
var SAFE_CLOSING = false;
try {
  called = 0;
  iteratorWithReturn = {
    next: function() {
      return { done: !!called++ };
    },
    "return": function() {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function() {
    return this;
  };
  Array.from(iteratorWithReturn, function() {
    throw 2;
  });
} catch (error2) {
}
var called;
var iteratorWithReturn;
var checkCorrectnessOfIteration = function(exec2, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING)
    return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function() {
      return {
        next: function() {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec2(object);
  } catch (error2) {
  }
  return ITERATION_SUPPORT;
};
var FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;
var promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function(iterable) {
  promiseNativeConstructor.all(iterable).then(void 0, function() {
  });
});
_export({ target: "Promise", stat: true, forced: promiseStaticsIncorrectIteration }, {
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability$1.f(C);
    var resolve2 = capability.resolve;
    var reject2 = capability.reject;
    var result = perform(function() {
      var $promiseResolve = aCallable(C.resolve);
      var values = [];
      var counter2 = 0;
      var remaining = 1;
      iterate(iterable, function(promise2) {
        var index = counter2++;
        var alreadyCalled = false;
        remaining++;
        functionCall($promiseResolve, C, promise2).then(function(value) {
          if (alreadyCalled)
            return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve2(values);
        }, reject2);
      });
      --remaining || resolve2(values);
    });
    if (result.error)
      reject2(result.value);
    return capability.promise;
  }
});
var FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;
var NativePromisePrototype = promiseNativeConstructor && promiseNativeConstructor.prototype;
_export({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {
  "catch": function(onRejected) {
    return this.then(void 0, onRejected);
  }
});
if (isCallable(promiseNativeConstructor)) {
  method = getBuiltIn("Promise").prototype["catch"];
  if (NativePromisePrototype["catch"] !== method) {
    defineBuiltIn(NativePromisePrototype, "catch", method, { unsafe: true });
  }
}
var method;
_export({ target: "Promise", stat: true, forced: promiseStaticsIncorrectIteration }, {
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability$1.f(C);
    var reject2 = capability.reject;
    var result = perform(function() {
      var $promiseResolve = aCallable(C.resolve);
      iterate(iterable, function(promise2) {
        functionCall($promiseResolve, C, promise2).then(capability.resolve, reject2);
      });
    });
    if (result.error)
      reject2(result.value);
    return capability.promise;
  }
});
var FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;
_export({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {
  reject: function reject(r) {
    var capability = newPromiseCapability$1.f(this);
    functionCall(capability.reject, void 0, r);
    return capability.promise;
  }
});
var promiseResolve = function(C, x) {
  anObject(C);
  if (isObject$2(x) && x.constructor === C)
    return x;
  var promiseCapability = newPromiseCapability$1.f(C);
  var resolve2 = promiseCapability.resolve;
  resolve2(x);
  return promiseCapability.promise;
};
var FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;
getBuiltIn("Promise");
_export({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
  resolve: function resolve(x) {
    return promiseResolve(this, x);
  }
});
var $assign = Object.assign;
var defineProperty$1 = Object.defineProperty;
var concat2 = functionUncurryThis([].concat);
var objectAssign = !$assign || fails(function() {
  if (descriptors$1 && $assign({ b: 1 }, $assign(defineProperty$1({}, "a", {
    enumerable: true,
    get: function() {
      defineProperty$1(this, "b", {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1)
    return true;
  var A = {};
  var B = {};
  var symbol = Symbol();
  var alphabet = "abcdefghijklmnopqrst";
  A[symbol] = 7;
  alphabet.split("").forEach(function(chr) {
    B[chr] = chr;
  });
  return $assign({}, A)[symbol] != 7 || objectKeys$1($assign({}, B)).join("") != alphabet;
}) ? function assign(target, source3) {
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
  var propertyIsEnumerable2 = objectPropertyIsEnumerable.f;
  while (argumentsLength > index) {
    var S = indexedObject(arguments[index++]);
    var keys4 = getOwnPropertySymbols ? concat2(objectKeys$1(S), getOwnPropertySymbols(S)) : objectKeys$1(S);
    var length = keys4.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys4[j++];
      if (!descriptors$1 || functionCall(propertyIsEnumerable2, S, key))
        T[key] = S[key];
    }
  }
  return T;
} : $assign;
_export({ target: "Object", stat: true, arity: 2, forced: Object.assign !== objectAssign }, {
  assign: objectAssign
});
var FUNCTION_NAME_EXISTS = functionName.EXISTS;
var defineProperty3 = objectDefineProperty.f;
var FunctionPrototype = Function.prototype;
var functionToString = functionUncurryThis(FunctionPrototype.toString);
var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
var regExpExec = functionUncurryThis(nameRE.exec);
var NAME = "name";
if (descriptors$1 && !FUNCTION_NAME_EXISTS) {
  defineProperty3(FunctionPrototype, NAME, {
    configurable: true,
    get: function() {
      try {
        return regExpExec(nameRE, functionToString(this))[1];
      } catch (error2) {
        return "";
      }
    }
  });
}
var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};
var classList = documentCreateElement("span").classList;
var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
var domTokenListPrototype = DOMTokenListPrototype === Object.prototype ? void 0 : DOMTokenListPrototype;
var push = functionUncurryThis([].push);
var createMethod = function(TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self2 = indexedObject(O);
    var boundFunction = functionBindContext(callbackfn, that);
    var length = lengthOfArrayLike(self2);
    var index = 0;
    var create2 = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create2($this, length) : IS_FILTER || IS_FILTER_REJECT ? create2($this, 0) : void 0;
    var value, result;
    for (; length > index; index++)
      if (NO_HOLES || index in self2) {
        value = self2[index];
        result = boundFunction(value, index, O);
        if (TYPE) {
          if (IS_MAP)
            target[index] = result;
          else if (result)
            switch (TYPE) {
              case 3:
                return true;
              case 5:
                return value;
              case 6:
                return index;
              case 2:
                push(target, value);
            }
          else
            switch (TYPE) {
              case 4:
                return false;
              case 7:
                push(target, value);
            }
        }
      }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};
var arrayIteration = {
  forEach: createMethod(0),
  map: createMethod(1),
  filter: createMethod(2),
  some: createMethod(3),
  every: createMethod(4),
  find: createMethod(5),
  findIndex: createMethod(6),
  filterReject: createMethod(7)
};
var $forEach = arrayIteration.forEach;
var STRICT_METHOD = arrayMethodIsStrict("forEach");
var arrayForEach = !STRICT_METHOD ? function forEach(callbackfn) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
} : [].forEach;
var handlePrototype = function(CollectionPrototype) {
  if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach)
    try {
      createNonEnumerableProperty(CollectionPrototype, "forEach", arrayForEach);
    } catch (error2) {
      CollectionPrototype.forEach = arrayForEach;
    }
};
for (COLLECTION_NAME in domIterables) {
  if (domIterables[COLLECTION_NAME]) {
    handlePrototype(global_1[COLLECTION_NAME] && global_1[COLLECTION_NAME].prototype);
  }
}
var COLLECTION_NAME;
handlePrototype(domTokenListPrototype);
var bind = function bind2(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};
var toString2 = Object.prototype.toString;
var kindOf = function(cache) {
  return function(thing) {
    var str = toString2.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  };
}(/* @__PURE__ */ Object.create(null));
function kindOfTest(type) {
  type = type.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type;
  };
}
var supportedProtocols = ["http:", "https:", "file:"];
function getProtocol(protocol) {
  return protocol || "http:";
}
function isArray$1(val) {
  return Array.isArray(val);
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
function isString$1(val) {
  return typeof val === "string";
}
function isNumber(val) {
  return typeof val === "number";
}
function isObject$1(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject(val) {
  if (kindOf(val) !== "object") {
    return false;
  }
  var prototype2 = Object.getPrototypeOf(val);
  return prototype2 === null || prototype2 === Object.prototype;
}
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
function isFunction(val) {
  return toString2.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject$1(val) && isFunction(val.pipe);
}
function isFormData(thing) {
  var pattern = "[object FormData]";
  return thing && (typeof FormData === "function" && thing instanceof FormData || toString2.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
}
var isURLSearchParams = kindOfTest("URLSearchParams");
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach2(obj, fn) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$1(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
function merge() {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray$1(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }
  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach2(arguments[i], assignValue);
  }
  return result;
}
function extend(a, b, thisArg) {
  forEach2(b, function assignValue(val, key) {
    if (thisArg && typeof val === "function") {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
function inherits(constructor, superConstructor, props, descriptors2) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  props && Object.assign(constructor.prototype, props);
}
function toFlatObject(sourceObj, destObj, filter) {
  var props;
  var i;
  var prop;
  var merged = {};
  destObj = destObj || {};
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if (!merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
}
function endsWith2(str, searchString, position) {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}
function toArray(thing) {
  if (!thing)
    return null;
  var i = thing.length;
  if (isUndefined(i))
    return null;
  var arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}
var isTypedArray = function(TypedArray) {
  return function(thing) {
    return TypedArray && thing instanceof TypedArray;
  };
}(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
var utils = {
  supportedProtocols,
  getProtocol,
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber,
  isObject: isObject$1,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isFunction,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach: forEach2,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith: endsWith2,
  toArray,
  isTypedArray,
  isFileList
};
function encode$1(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL = function buildURL2(url2, params, paramsSerializer) {
  if (!params) {
    return url2;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils.isArray(val)) {
        key = key + "[]";
      } else {
        val = [val];
      }
      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode$1(key) + "=" + encode$1(v));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
};
function InterceptorManager() {
  this.handlers = [];
}
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager.prototype.eject = function eject(id2) {
  if (this.handlers[id2]) {
    this.handlers[id2] = null;
  }
};
InterceptorManager.prototype.forEach = function forEach3(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};
var InterceptorManager_1 = InterceptorManager;
var normalizeHeaderName = function normalizeHeaderName2(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name2) {
    if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name2];
    }
  });
};
function AxiosError(message, code, config, request2, response) {
  Error.call(this);
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request2 && (this.request = request2);
  response && (this.response = response);
}
utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED"
].forEach(function(code) {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = function(error2, code, config, request2, response, customProps) {
  var axiosError = Object.create(prototype);
  utils.toFlatObject(error2, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  });
  AxiosError.call(axiosError, error2.message, code, config, request2, response);
  axiosError.name = error2.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_1 = AxiosError;
var transitional = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
transitional.silentJSONParsing;
transitional.forcedJSONParsing;
transitional.clarifyTimeoutError;
function toFormData(obj, formData) {
  formData = formData || new FormData();
  var stack = [];
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils.isDate(value)) {
      return value.toISOString();
    }
    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function build(data2, parentKey) {
    if (utils.isPlainObject(data2) || utils.isArray(data2)) {
      if (stack.indexOf(data2) !== -1) {
        throw Error("Circular reference detected in " + parentKey);
      }
      stack.push(data2);
      utils.forEach(data2, function each(value, key) {
        if (utils.isUndefined(value))
          return;
        var fullKey = parentKey ? parentKey + "." + key : key;
        var arr;
        if (value && !parentKey && typeof value === "object") {
          if (utils.endsWith(key, "{}")) {
            value = JSON.stringify(value);
          } else if (utils.endsWith(key, "[]") && (arr = utils.toArray(value))) {
            arr.forEach(function(el) {
              !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
            });
            return;
          }
        }
        build(value, fullKey);
      });
      stack.pop();
    } else {
      formData.append(parentKey, convertValue(data2));
    }
  }
  build(obj);
  return formData;
}
var toFormData_1 = toFormData;
var settle = function settle2(resolve2, reject2, response) {
  var validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject2(new AxiosError_1(
      "Request failed with status code " + response.status,
      [AxiosError_1.ERR_BAD_REQUEST, AxiosError_1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
};
var cookies = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
  return {
    write: function write(name2, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name2 + "=" + encodeURIComponent(value));
      if (utils.isNumber(expires)) {
        cookie.push("expires=" + new Date(expires).toGMTString());
      }
      if (utils.isString(path)) {
        cookie.push("path=" + path);
      }
      if (utils.isString(domain)) {
        cookie.push("domain=" + domain);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      document.cookie = cookie.join("; ");
    },
    read: function read(name2) {
      var match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match2 ? decodeURIComponent(match2[3]) : null;
    },
    remove: function remove(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  };
}() : function nonStandardBrowserEnv() {
  return {
    write: function write() {
    },
    read: function read() {
      return null;
    },
    remove: function remove() {
    }
  };
}();
var isAbsoluteURL = function isAbsoluteURL2(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
};
var combineURLs = function combineURLs2(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var buildFullPath = function buildFullPath2(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};
var ignoreDuplicateOf = [
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
];
var parseHeaders = function parseHeaders2(headers) {
  var parsed = {};
  var key;
  var val;
  var i;
  if (!headers) {
    return parsed;
  }
  utils.forEach(headers.split("\n"), function parser(line) {
    i = line.indexOf(":");
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));
    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === "set-cookie") {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    }
  });
  return parsed;
};
var isURLSameOrigin = utils.isStandardBrowserEnv() ? function standardBrowserEnv2() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement("a");
  var originURL;
  function resolveURL(url2) {
    var href = url2;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin2(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin2() {
    return true;
  };
}();
var maxInt = 2147483647;
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter = "-";
var regexNonASCII = /[^\x20-\x7E]/;
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
var errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;
function error(type) {
  throw new RangeError(errors[type]);
}
function map$1(array, fn) {
  var length = array.length;
  var result = [];
  while (length--) {
    result[length] = fn(array[length]);
  }
  return result;
}
function mapDomain(string, fn) {
  var parts = string.split("@");
  var result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    string = parts[1];
  }
  string = string.replace(regexSeparators, ".");
  var labels = string.split(".");
  var encoded = map$1(labels, fn).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  var output = [], counter2 = 0, length = string.length, value, extra;
  while (counter2 < length) {
    value = string.charCodeAt(counter2++);
    if (value >= 55296 && value <= 56319 && counter2 < length) {
      extra = string.charCodeAt(counter2++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter2--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function digitToBasic(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
  var k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
}
function encode(input) {
  var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
  input = ucs2decode(input);
  inputLength = input.length;
  n = initialN;
  delta = 0;
  bias = initialBias;
  for (j = 0; j < inputLength; ++j) {
    currentValue = input[j];
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  handledCPCount = basicLength = output.length;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    for (m = maxInt, j = 0; j < inputLength; ++j) {
      currentValue = input[j];
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }
    handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m - n) * handledCPCountPlusOne;
    n = m;
    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];
      if (currentValue < n && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue == n) {
        for (q = delta, k = base; ; k += base) {
          t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t) {
            break;
          }
          qMinusT = q - t;
          baseMinusT = base - t;
          output.push(
            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
          );
          q = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join("");
}
function toASCII(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
  });
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isString(arg) {
  return typeof arg === "string";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var isArray2 = Array.isArray || function(xs) {
  return Object.prototype.toString.call(xs) === "[object Array]";
};
function stringifyPrimitive(v) {
  switch (typeof v) {
    case "string":
      return v;
    case "boolean":
      return v ? "true" : "false";
    case "number":
      return isFinite(v) ? v : "";
    default:
      return "";
  }
}
function stringify(obj, sep, eq, name2) {
  sep = sep || "&";
  eq = eq || "=";
  if (obj === null) {
    obj = void 0;
  }
  if (typeof obj === "object") {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray2(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }
  if (!name2)
    return "";
  return encodeURIComponent(stringifyPrimitive(name2)) + eq + encodeURIComponent(stringifyPrimitive(obj));
}
function map(xs, f2) {
  if (xs.map)
    return xs.map(f2);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f2(xs[i], i));
  }
  return res;
}
var objectKeys = Object.keys || function(obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key))
      res.push(key);
  }
  return res;
};
function parse$1(qs, sep, eq, options) {
  sep = sep || "&";
  eq = eq || "=";
  var obj = {};
  if (typeof qs !== "string" || qs.length === 0) {
    return obj;
  }
  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1e3;
  if (options && typeof options.maxKeys === "number") {
    maxKeys = options.maxKeys;
  }
  var len = qs.length;
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }
  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = "";
    }
    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);
    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray2(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }
  return obj;
}
var url = {
  parse: urlParse,
  resolve: urlResolve,
  resolveObject: urlResolveObject,
  fileURLToPath: urlFileURLToPath,
  format: urlFormat,
  Url
};
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i;
var portPattern = /:[0-9]*$/;
var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
var autoEscape = ["'"].concat(unwise);
var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
var hostEndingChars = ["/", "?", "#"];
var hostnameMaxLen = 255;
var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var unsafeProtocol = {
  "javascript": true,
  "javascript:": true
};
var hostlessProtocol = {
  "javascript": true,
  "javascript:": true
};
var slashedProtocol = {
  "http": true,
  "https": true,
  "ftp": true,
  "gopher": true,
  "file": true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url2, parseQueryString, slashesDenoteHost) {
  if (url2 && isObject(url2) && url2 instanceof Url)
    return url2;
  var u = new Url();
  u.parse(url2, parseQueryString, slashesDenoteHost);
  return u;
}
Url.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
  return parse(this, url2, parseQueryString, slashesDenoteHost);
};
function parse(self2, url2, parseQueryString, slashesDenoteHost) {
  if (!isString(url2)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
  }
  var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, "/");
  url2 = uSplit.join(splitter);
  var rest = url2;
  rest = rest.trim();
  if (!slashesDenoteHost && url2.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      self2.path = rest;
      self2.href = rest;
      self2.pathname = simplePath[1];
      if (simplePath[2]) {
        self2.search = simplePath[2];
        if (parseQueryString) {
          self2.query = parse$1(self2.search.substr(1));
        } else {
          self2.query = self2.search.substr(1);
        }
      } else if (parseQueryString) {
        self2.search = "";
        self2.query = {};
      }
      return self2;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    self2.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      self2.slashes = true;
    }
  }
  var i, hec, l, p;
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      self2.auth = decodeURIComponent(auth);
    }
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    if (hostEnd === -1)
      hostEnd = rest.length;
    self2.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    parseHost(self2);
    self2.hostname = self2.hostname || "";
    var ipv6Hostname = self2.hostname[0] === "[" && self2.hostname[self2.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = self2.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part)
          continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              newpart += "x";
            } else {
              newpart += part[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest;
            }
            self2.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (self2.hostname.length > hostnameMaxLen) {
      self2.hostname = "";
    } else {
      self2.hostname = self2.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      self2.hostname = toASCII(self2.hostname);
    }
    p = self2.port ? ":" + self2.port : "";
    var h = self2.hostname || "";
    self2.host = h + p;
    self2.href += self2.host;
    if (ipv6Hostname) {
      self2.hostname = self2.hostname.substr(1, self2.hostname.length - 2);
      if (rest[0] !== "/") {
        rest = "/" + rest;
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }
  var hash = rest.indexOf("#");
  if (hash !== -1) {
    self2.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    self2.search = rest.substr(qm);
    self2.query = rest.substr(qm + 1);
    if (parseQueryString) {
      self2.query = parse$1(self2.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    self2.search = "";
    self2.query = {};
  }
  if (rest)
    self2.pathname = rest;
  if (slashedProtocol[lowerProto] && self2.hostname && !self2.pathname) {
    self2.pathname = "/";
  }
  if (self2.pathname || self2.search) {
    p = self2.pathname || "";
    var s = self2.search || "";
    self2.path = p + s;
  }
  self2.href = format(self2);
  return self2;
}
function urlFileURLToPath(path) {
  if (typeof path === "string")
    path = new Url().parse(path);
  else if (!(path instanceof Url))
    throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof path + String(path));
  if (path.protocol !== "file:")
    throw new TypeError("The URL must be of scheme file");
  return getPathFromURLPosix(path);
}
function getPathFromURLPosix(url2) {
  const pathname = url2.pathname;
  for (let n = 0; n < pathname.length; n++) {
    if (pathname[n] === "%") {
      const third = pathname.codePointAt(n + 2) | 32;
      if (pathname[n + 1] === "2" && third === 102) {
        throw new TypeError(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function urlFormat(obj) {
  if (isString(obj))
    obj = parse({}, obj);
  return format(obj);
}
function format(self2) {
  var auth = self2.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol = self2.protocol || "", pathname = self2.pathname || "", hash = self2.hash || "", host = false, query = "";
  if (self2.host) {
    host = auth + self2.host;
  } else if (self2.hostname) {
    host = auth + (self2.hostname.indexOf(":") === -1 ? self2.hostname : "[" + this.hostname + "]");
    if (self2.port) {
      host += ":" + self2.port;
    }
  }
  if (self2.query && isObject(self2.query) && Object.keys(self2.query).length) {
    query = stringify(self2.query);
  }
  var search = self2.search || query && "?" + query || "";
  if (protocol && protocol.substr(-1) !== ":")
    protocol += ":";
  if (self2.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname.charAt(0) !== "/")
      pathname = "/" + pathname;
  } else if (!host) {
    host = "";
  }
  if (hash && hash.charAt(0) !== "#")
    hash = "#" + hash;
  if (search && search.charAt(0) !== "?")
    search = "?" + search;
  pathname = pathname.replace(/[?#]/g, function(match2) {
    return encodeURIComponent(match2);
  });
  search = search.replace("#", "%23");
  return protocol + host + pathname + search + hash;
}
Url.prototype.format = function() {
  return format(this);
};
function urlResolve(source3, relative) {
  return urlParse(source3, false, true).resolve(relative);
}
Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};
function urlResolveObject(source3, relative) {
  if (!source3)
    return relative;
  return urlParse(source3, false, true).resolveObject(relative);
}
Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }
  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }
  result.hash = relative.hash;
  if (relative.href === "") {
    result.href = result.format();
    return result;
  }
  if (relative.slashes && !relative.protocol) {
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== "protocol")
        result[rkey] = relative[rkey];
    }
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = "/";
    }
    result.href = result.format();
    return result;
  }
  var relPath;
  if (relative.protocol && relative.protocol !== result.protocol) {
    if (!slashedProtocol[relative.protocol]) {
      var keys4 = Object.keys(relative);
      for (var v = 0; v < keys4.length; v++) {
        var k = keys4[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }
    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      relPath = (relative.pathname || "").split("/");
      while (relPath.length && !(relative.host = relPath.shift()))
        ;
      if (!relative.host)
        relative.host = "";
      if (!relative.hostname)
        relative.hostname = "";
      if (relPath[0] !== "")
        relPath.unshift("");
      if (relPath.length < 2)
        relPath.unshift("");
      result.pathname = relPath.join("/");
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || "";
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    if (result.pathname || result.search) {
      var p = result.pathname || "";
      var s = result.search || "";
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }
  var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
  relPath = relative.pathname && relative.pathname.split("/") || [];
  if (psychotic) {
    result.hostname = "";
    result.port = null;
    if (result.host) {
      if (srcPath[0] === "")
        srcPath[0] = result.host;
      else
        srcPath.unshift(result.host);
    }
    result.host = "";
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === "")
          relPath[0] = relative.host;
        else
          relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
  }
  var authInHost;
  if (isRelAbs) {
    result.host = relative.host || relative.host === "" ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
  } else if (relPath.length) {
    if (!srcPath)
      srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.href = result.format();
    return result;
  }
  if (!srcPath.length) {
    result.pathname = null;
    if (result.search) {
      result.path = "/" + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }
  var last2 = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last2 === "." || last2 === "..") || last2 === "";
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last2 = srcPath[i];
    if (last2 === ".") {
      srcPath.splice(i, 1);
    } else if (last2 === "..") {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift("..");
    }
  }
  if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
    srcPath.unshift("");
  }
  if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
    srcPath.push("");
  }
  var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
    authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }
  mustEndAbs = mustEndAbs || result.host && srcPath.length;
  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift("");
  }
  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join("/");
  }
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};
Url.prototype.parseHost = function() {
  return parseHost(this);
};
function parseHost(self2) {
  var host = self2.host;
  var port2 = portPattern.exec(host);
  if (port2) {
    port2 = port2[0];
    if (port2 !== ":") {
      self2.port = port2.substr(1);
    }
    host = host.substr(0, host.length - port2.length);
  }
  if (host)
    self2.hostname = host;
}
function CanceledError(message) {
  AxiosError_1.call(this, message == null ? "canceled" : message, AxiosError_1.ERR_CANCELED);
  this.name = "CanceledError";
}
utils.inherits(CanceledError, AxiosError_1, {
  __CANCEL__: true
});
var CanceledError_1 = CanceledError;
var xhr = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve2, reject2) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    var request2 = new XMLHttpRequest();
    if (config.auth) {
      var username = config.auth.username || "";
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
    }
    var fullPath = buildFullPath(config.baseURL, config.url);
    var parsed = url.parse(fullPath);
    var protocol = utils.getProtocol(parsed.protocol);
    request2.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request2.timeout = config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders(request2.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      var response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config,
        request: request2
      };
      settle(function _resolve(value) {
        resolve2(value);
        done();
      }, function _reject(err) {
        reject2(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject2(new AxiosError_1("Request aborted", AxiosError_1.ECONNABORTED, config, request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject2(new AxiosError_1("Network Error", AxiosError_1.ERR_NETWORK, config, request2, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      var transitional$1 = config.transitional || transitional;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject2(new AxiosError_1(
        timeoutErrorMessage,
        transitional$1.clarifyTimeoutError ? AxiosError_1.ETIMEDOUT : AxiosError_1.ECONNABORTED,
        config,
        request2
      ));
      request2 = null;
    };
    if (utils.isStandardBrowserEnv()) {
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }
    if ("setRequestHeader" in request2) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
          delete requestHeaders[key];
        } else {
          request2.setRequestHeader(key, val);
        }
      });
    }
    if (!utils.isUndefined(config.withCredentials)) {
      request2.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request2.addEventListener("progress", config.onDownloadProgress);
    }
    if (typeof config.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", config.onUploadProgress);
    }
    if (config.cancelToken || config.signal) {
      onCanceled = function(cancel) {
        if (!request2) {
          return;
        }
        reject2(!cancel || cancel && cancel.type ? new CanceledError_1() : cancel);
        request2.abort();
        request2 = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    if (!requestData) {
      requestData = null;
    }
    if (parsed.path === null) {
      reject2(new AxiosError_1("Malformed URL " + fullPath, AxiosError_1.ERR_BAD_REQUEST, config));
      return;
    }
    if (!utils.supportedProtocols.includes(protocol)) {
      reject2(new AxiosError_1("Unsupported protocol " + protocol, AxiosError_1.ERR_BAD_REQUEST, config));
      return;
    }
    request2.send(requestData);
  });
};
var _null = null;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = xhr;
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = xhr;
  }
  return adapter;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional,
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data2, headers) {
    normalizeHeaderName(headers, "Accept");
    normalizeHeaderName(headers, "Content-Type");
    if (utils.isFormData(data2) || utils.isArrayBuffer(data2) || utils.isBuffer(data2) || utils.isStream(data2) || utils.isFile(data2) || utils.isBlob(data2)) {
      return data2;
    }
    if (utils.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils.isURLSearchParams(data2)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data2.toString();
    }
    var isObjectPayload = utils.isObject(data2);
    var contentType = headers && headers["Content-Type"];
    var isFileList2;
    if ((isFileList2 = utils.isFileList(data2)) || isObjectPayload && contentType === "multipart/form-data") {
      var _FormData = this.env && this.env.FormData;
      return toFormData_1(isFileList2 ? { "files[]": data2 } : data2, _FormData && new _FormData());
    } else if (isObjectPayload || contentType === "application/json") {
      setContentTypeIfUnset(headers, "application/json");
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    var transitional3 = this.transitional || defaults.transitional;
    var silentJSONParsing = transitional3 && transitional3.silentJSONParsing;
    var forcedJSONParsing = transitional3 && transitional3.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
    if (strictJSONParsing || forcedJSONParsing && utils.isString(data2) && data2.length) {
      try {
        return JSON.parse(data2);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_1.from(e, AxiosError_1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data2;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: _null
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults;
var transformData = function transformData2(data2, headers, fns) {
  var context = this || defaults_1;
  utils.forEach(fns, function transform(fn) {
    data2 = fn.call(context, data2, headers);
  });
  return data2;
};
var isCancel = function isCancel2(value) {
  return !!(value && value.__CANCEL__);
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_1();
  }
}
var dispatchRequest = function dispatchRequest2(config) {
  throwIfCancellationRequested(config);
  config.headers = config.headers || {};
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );
  utils.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );
  var adapter = config.adapter || defaults_1.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }
    return Promise.reject(reason);
  });
};
var mergeConfig = function mergeConfig2(config1, config2) {
  config2 = config2 || {};
  var config = {};
  function getMergedValue(target, source3) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source3)) {
      return utils.merge(target, source3);
    } else if (utils.isPlainObject(source3)) {
      return utils.merge({}, source3);
    } else if (utils.isArray(source3)) {
      return source3.slice();
    }
    return source3;
  }
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    }
  }
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  var mergeMap = {
    "url": valueFromConfig2,
    "method": valueFromConfig2,
    "data": valueFromConfig2,
    "baseURL": defaultToConfig2,
    "transformRequest": defaultToConfig2,
    "transformResponse": defaultToConfig2,
    "paramsSerializer": defaultToConfig2,
    "timeout": defaultToConfig2,
    "timeoutMessage": defaultToConfig2,
    "withCredentials": defaultToConfig2,
    "adapter": defaultToConfig2,
    "responseType": defaultToConfig2,
    "xsrfCookieName": defaultToConfig2,
    "xsrfHeaderName": defaultToConfig2,
    "onUploadProgress": defaultToConfig2,
    "onDownloadProgress": defaultToConfig2,
    "decompress": defaultToConfig2,
    "maxContentLength": defaultToConfig2,
    "maxBodyLength": defaultToConfig2,
    "beforeRedirect": defaultToConfig2,
    "transport": defaultToConfig2,
    "httpAgent": defaultToConfig2,
    "httpsAgent": defaultToConfig2,
    "cancelToken": defaultToConfig2,
    "socketPath": defaultToConfig2,
    "responseEncoding": defaultToConfig2,
    "validateStatus": mergeDirectKeys
  };
  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge2 = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge2(prop);
    utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
};
var data = {
  "version": "0.27.0"
};
var VERSION = data.version;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators$1.transitional = function transitional2(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new AxiosError_1(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError_1.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_1("options must be an object", AxiosError_1.ERR_BAD_OPTION_VALUE);
  }
  var keys4 = Object.keys(options);
  var i = keys4.length;
  while (i-- > 0) {
    var opt = keys4[i];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options[opt];
      var result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError_1("option " + opt + " must be " + result, AxiosError_1.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_1("Unknown option " + opt, AxiosError_1.ERR_BAD_OPTION);
    }
  }
}
var validator = {
  assertOptions,
  validators: validators$1
};
var validators = validator.validators;
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager_1(),
    response: new InterceptorManager_1()
  };
}
Axios.prototype.request = function request(configOrUrl, config) {
  if (typeof configOrUrl === "string") {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }
  config = mergeConfig(this.defaults, config);
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = "get";
  }
  var transitional3 = config.transitional;
  if (transitional3 !== void 0) {
    validator.assertOptions(transitional3, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise2;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise2 = Promise.resolve(config);
    while (chain.length) {
      promise2 = promise2.then(chain.shift(), chain.shift());
    }
    return promise2;
  }
  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error2) {
      onRejected(error2);
      break;
    }
  }
  try {
    promise2 = dispatchRequest(newConfig);
  } catch (error2) {
    return Promise.reject(error2);
  }
  while (responseInterceptorChain.length) {
    promise2 = promise2.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise2;
};
Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  var fullPath = buildFullPath(config.baseURL, config.url);
  return buildURL(fullPath, config.params, config.paramsSerializer);
};
utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios.prototype[method] = function(url2, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data2, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data: data2
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_1 = Axios;
function CancelToken(executor) {
  if (typeof executor !== "function") {
    throw new TypeError("executor must be a function.");
  }
  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve2) {
    resolvePromise = resolve2;
  });
  var token = this;
  this.promise.then(function(cancel) {
    if (!token._listeners)
      return;
    var i;
    var l = token._listeners.length;
    for (i = 0; i < l; i++) {
      token._listeners[i](cancel);
    }
    token._listeners = null;
  });
  this.promise.then = function(onfulfilled) {
    var _resolve;
    var promise2 = new Promise(function(resolve2) {
      token.subscribe(resolve2);
      _resolve = resolve2;
    }).then(onfulfilled);
    promise2.cancel = function reject2() {
      token.unsubscribe(_resolve);
    };
    return promise2;
  };
  executor(function cancel(message) {
    if (token.reason) {
      return;
    }
    token.reason = new CanceledError_1(message);
    resolvePromise(token.reason);
  });
}
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
CancelToken.prototype.subscribe = function subscribe(listener2) {
  if (this.reason) {
    listener2(this.reason);
    return;
  }
  if (this._listeners) {
    this._listeners.push(listener2);
  } else {
    this._listeners = [listener2];
  }
};
CancelToken.prototype.unsubscribe = function unsubscribe(listener2) {
  if (!this._listeners) {
    return;
  }
  var index = this._listeners.indexOf(listener2);
  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token,
    cancel
  };
};
var CancelToken_1 = CancelToken;
var spread = function spread2(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};
var isAxiosError = function isAxiosError2(payload) {
  return utils.isObject(payload) && payload.isAxiosError === true;
};
function createInstance(defaultConfig) {
  var context = new Axios_1(defaultConfig);
  var instance = bind(Axios_1.prototype.request, context);
  utils.extend(instance, Axios_1.prototype, context);
  utils.extend(instance, context);
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios$1 = createInstance(defaults_1);
axios$1.Axios = Axios_1;
axios$1.CanceledError = CanceledError_1;
axios$1.CancelToken = CancelToken_1;
axios$1.isCancel = isCancel;
axios$1.VERSION = data.version;
axios$1.toFormData = toFormData_1;
axios$1.AxiosError = AxiosError_1;
axios$1.Cancel = axios$1.CanceledError;
axios$1.all = function all2(promises) {
  return Promise.all(promises);
};
axios$1.spread = spread;
axios$1.isAxiosError = isAxiosError;
var axios_1 = axios$1;
var default_1 = axios$1;
axios_1.default = default_1;
var axios = axios_1;
var name$1 = "@tryghost/content-api";
var version = "1.11.1";
var repository = "https://github.com/TryGhost/SDK/tree/master/packages/content-api";
var author = "Ghost Foundation";
var license = "MIT";
var main = "cjs/content-api.js";
var unpkg = "umd/content-api.min.js";
var module = "es/content-api.js";
var source2 = "lib/content-api.js";
var files = [
  "LICENSE",
  "README.md",
  "cjs/",
  "lib/",
  "umd/",
  "es/"
];
var scripts = {
  dev: 'echo "Implement me!"',
  pretest: "yarn build",
  test: "NODE_ENV=testing c8 --all --reporter text --reporter cobertura mocha './test/**/*.test.js'",
  build: "rollup -c",
  lint: "eslint . --ext .js --cache",
  prepare: "NODE_ENV=production yarn build",
  posttest: "yarn lint"
};
var publishConfig = {
  access: "public"
};
var devDependencies = {
  "@babel/core": "7.18.10",
  "@babel/polyfill": "7.12.1",
  "@babel/preset-env": "7.18.10",
  "@rollup/plugin-json": "4.1.0",
  c8: "7.12.0",
  "core-js": "3.24.1",
  "eslint-plugin-ghost": "2.14.0",
  mocha: "10.0.0",
  rollup: "2.77.2",
  "rollup-plugin-babel": "4.4.0",
  "rollup-plugin-commonjs": "10.1.0",
  "rollup-plugin-node-resolve": "5.2.0",
  "rollup-plugin-polyfill-node": "0.10.2",
  "rollup-plugin-replace": "2.2.0",
  "rollup-plugin-terser": "7.0.2",
  should: "13.2.3",
  sinon: "14.0.0"
};
var dependencies = {
  axios: "^0.27.0"
};
var gitHead = "9251588cb81347205c5dab850636bba4c86fe58d";
var packageInfo = {
  name: name$1,
  version,
  repository,
  author,
  license,
  main,
  "umd:main": "umd/content-api.min.js",
  unpkg,
  module,
  source: source2,
  files,
  scripts,
  publishConfig,
  devDependencies,
  dependencies,
  gitHead
};
var USER_AGENT_DEFAULT = false;
var packageVersion = packageInfo.version;
var defaultAcceptVersionHeader = "v5.0";
var supportedVersions = ["v2", "v3", "v4", "v5", "canary"];
var name = "@tryghost/content-api";
var resolveAPIPrefix = function resolveAPIPrefix2(version2) {
  var prefix;
  if (version2 === "v5" || version2 === void 0 || version2.match(/^v5\.\d+/)) {
    prefix = "/content/";
  } else if (version2.match(/^v\d+\.\d+/)) {
    var versionPrefix = /^(v\d+)\.\d+/.exec(version2)[1];
    prefix = "/".concat(versionPrefix, "/content/");
  } else {
    prefix = "/".concat(version2, "/content/");
  }
  return prefix;
};
var defaultMakeRequest = function defaultMakeRequest2(_ref) {
  var url2 = _ref.url, method = _ref.method, params = _ref.params, headers = _ref.headers;
  return axios[method](url2, {
    params,
    paramsSerializer: function paramsSerializer(parameters) {
      return Object.keys(parameters).reduce(function(parts, k) {
        var val = encodeURIComponent([].concat(parameters[k]).join(","));
        return parts.concat("".concat(k, "=").concat(val));
      }, []).join("&");
    },
    headers
  });
};
function GhostContentAPI(_ref2) {
  var url2 = _ref2.url, key = _ref2.key, host = _ref2.host, version2 = _ref2.version, userAgent = _ref2.userAgent, _ref2$ghostPath = _ref2.ghostPath, ghostPath = _ref2$ghostPath === void 0 ? "ghost" : _ref2$ghostPath, _ref2$makeRequest = _ref2.makeRequest, makeRequest = _ref2$makeRequest === void 0 ? defaultMakeRequest : _ref2$makeRequest;
  if (host) {
    console.warn("".concat(name, ": The 'host' parameter is deprecated, please use 'url' instead"));
    if (!url2) {
      url2 = host;
    }
  }
  if (this instanceof GhostContentAPI) {
    return GhostContentAPI({
      url: url2,
      key,
      version: version2,
      userAgent,
      ghostPath,
      makeRequest
    });
  }
  if (version2 === void 0) {
    throw new Error("".concat(name, " Config Missing: 'version' is required. E.g. ").concat(supportedVersions.join(",")));
  }
  var acceptVersionHeader;
  if (typeof version2 === "boolean") {
    if (version2 === true) {
      acceptVersionHeader = defaultAcceptVersionHeader;
    }
    version2 = void 0;
  } else if (version2 && !supportedVersions.includes(version2) && !version2.match(/^v\d+\.\d+/)) {
    throw new Error("".concat(name, " Config Invalid: 'version' ").concat(version2, " is not supported"));
  } else {
    if (version2 === "canary") {
      console.warn("".concat(name, ": The 'version' parameter has a deprecated format 'canary', please use 'v{major}.{minor}' format instead"));
      acceptVersionHeader = defaultAcceptVersionHeader;
    } else if (version2.match(/^v\d+$/)) {
      console.warn("".concat(name, ": The 'version' parameter has a deprecated format 'v{major}', please use 'v{major}.{minor}' format instead"));
      acceptVersionHeader = "".concat(version2, ".0");
    } else {
      acceptVersionHeader = version2;
    }
  }
  if (!url2) {
    throw new Error("".concat(name, " Config Missing: 'url' is required. E.g. 'https://site.com'"));
  }
  if (!/https?:\/\//.test(url2)) {
    throw new Error("".concat(name, " Config Invalid: 'url' ").concat(url2, " requires a protocol. E.g. 'https://site.com'"));
  }
  if (url2.endsWith("/")) {
    throw new Error("".concat(name, " Config Invalid: 'url' ").concat(url2, " must not have a trailing slash. E.g. 'https://site.com'"));
  }
  if (ghostPath.endsWith("/") || ghostPath.startsWith("/")) {
    throw new Error("".concat(name, " Config Invalid: 'ghostPath' ").concat(ghostPath, " must not have a leading or trailing slash. E.g. 'ghost'"));
  }
  if (key && !/[0-9a-f]{26}/.test(key)) {
    throw new Error("".concat(name, " Config Invalid: 'key' ").concat(key, " must have 26 hex characters"));
  }
  if (userAgent === void 0) {
    userAgent = USER_AGENT_DEFAULT;
  }
  var api = ["posts", "authors", "tags", "pages", "settings", "tiers", "newsletters", "offers"].reduce(function(apiObject, resourceType) {
    function browse() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var memberToken = arguments.length > 1 ? arguments[1] : void 0;
      return makeApiRequest(resourceType, options, null, memberToken);
    }
    function read(data2) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var memberToken = arguments.length > 2 ? arguments[2] : void 0;
      if (!data2 || !data2.id && !data2.slug) {
        return Promise.reject(new Error("".concat(name, " read requires an id or slug.")));
      }
      var params = Object.assign({}, data2, options);
      return makeApiRequest(resourceType, params, data2.id || "slug/".concat(data2.slug), memberToken);
    }
    return Object.assign(apiObject, _defineProperty({}, resourceType, {
      read,
      browse
    }));
  }, {});
  delete api.settings.read;
  delete api.tiers.read;
  delete api.newsletters.read;
  delete api.offers.browse;
  return api;
  function makeApiRequest(resourceType, params, id2) {
    var membersToken = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    if (!membersToken && !key) {
      return Promise.reject(new Error("".concat(name, " Config Missing: 'key' is required.")));
    }
    delete params.id;
    var headers = membersToken ? {
      Authorization: "GhostMembers ".concat(membersToken)
    } : {};
    if (userAgent) {
      if (typeof userAgent === "boolean") {
        headers["User-Agent"] = "GhostContentSDK/".concat(packageVersion);
      } else {
        headers["User-Agent"] = userAgent;
      }
    }
    if (acceptVersionHeader) {
      headers["Accept-Version"] = acceptVersionHeader;
    }
    params = Object.assign({
      key
    }, params);
    var apiUrl = "".concat(url2, "/").concat(ghostPath, "/api").concat(resolveAPIPrefix(version2)).concat(resourceType, "/").concat(id2 ? id2 + "/" : "");
    return makeRequest({
      url: apiUrl,
      method: "get",
      params,
      headers
    }).then(function(res) {
      if (!Array.isArray(res.data[resourceType])) {
        return res.data[resourceType];
      }
      if (res.data[resourceType].length === 1 && !res.data.meta) {
        return res.data[resourceType][0];
      }
      return Object.assign(res.data[resourceType], {
        meta: res.data.meta
      });
    }).catch(function(err) {
      if (err.response && err.response.data && err.response.data.errors) {
        var props = err.response.data.errors[0];
        var toThrow = new Error(props.message);
        var keys4 = Object.keys(props);
        toThrow.name = props.type;
        keys4.forEach(function(k) {
          toThrow[k] = props[k];
        });
        toThrow.response = err.response;
        toThrow.request = err.request;
        toThrow.config = err.config;
        throw toThrow;
      } else {
        throw err;
      }
    });
  }
}

// dep:@tryghost_content-api
var tryghost_content_api_default = GhostContentAPI;
export {
  tryghost_content_api_default as default
};
/*! https://mths.be/punycode v1.4.1 by @mathias */
//# sourceMappingURL=@tryghost_content-api.js.map
